# Project 0: Getting Real

## Preliminaries

>Fill in your name and email address.
>>name:冯之乐 email address:2100012941@stu.pku.edu.cn
 

>If you have any preliminary comments on your submission, notes for the TAs, please give them here.



>Please cite any offline or online sources you consulted while preparing your submission, other than the Pintos documentation, course text, lecture notes, and course staff.



## Booting Pintos

>A1: Put the screenshot of Pintos running example here.
>>![qemu_boot](https://github.com/FZYsheep/MarkdownPicture/blob/8496823265644de9c392485a8c95069922613f1a/qemu_boot.png)
>>![bochs_boot](https://github.com/FZYsheep/MarkdownPicture/blob/8496823265644de9c392485a8c95069922613f1a/bochs_boot.png)


## Debugging

#### QUESTIONS: BIOS 

>B1: What is the first instruction that gets executed?

>>ljmp   $0x3630,$0xf000e05b

>B2: At which physical address is this instruction located?

>>0xffff0


#### QUESTIONS: BOOTLOADER

>B3: How does the bootloader read disk sectors? In particular, what BIOS interrupt is used?

>>we should have a look at **read_sector**:  
>>It first pushes some parameters essential for looking for the disk sector we are ready to read(CHS addressing),then uses BIOS interrupt 0x13.  
>>This kind of BIOS interrupt triggers a control transfer from user’s face program to an kernel’s face exception handler.  
>>From [the picture](https://en.wikipedia.org/wiki/BIOS_interrupt_call#:~:text=Extended%20Read%20Sectors) on Wikipedia,we could know that this kind of BIOS interrupt can provide sector-based hard disk and floppy disk read and write services.  
>>And from the line in loader.S:  
>>mov $0x42,%ah  
>>we can know exactly the functionality of the BIOS interrupt here is reading sectors from drive. 

>B4: How does the bootloader decides whether it successfully finds the Pintos kernel?

>>![**First,check if the partition is used.**](https://github.com/FZYsheep/MarkdownPicture/blob/1b2094241508e362bb87d3ca7e212fcbc115e489/check1.png)
>>
>>If it is unused,go to the next partition(call next_partition function).If it is used,go on checking this partition.
>>
>>![**Then,check the type of this partition.**](https://github.com/FZYsheep/MarkdownPicture/blob/1b2094241508e362bb87d3ca7e212fcbc115e489/check2.png)
>>
>>If the type of this partition is the same the pintos kernel,we continue our examination for this partition.if not,we go to the next partition.
>>
>>![**Finally,check if this partition is bootable.**](https://github.com/FZYsheep/MarkdownPicture/blob/1b2094241508e362bb87d3ca7e212fcbc115e489/check3.png)
>>
>>If it is bootable,we finally find the bootloader,all we need to do next is to load the kernel into the physical memory.

>B5: What happens when the bootloader could not find the Pintos kernel?

>>If we couldn’t find kernel,print “Not found”.Then use BIOS interrupt 0x18 to notify BIOS that no bootable disk is present so that boot failed.


>B6: At what point and how exactly does the bootloader transfer control to the Pintos kernel?

>>**what point:**
>>After finding kernel,loader starts to read the disk char by char and load the kernel into memory which starts at 0x2000. After this process finishes,the bootloader transfer control to kernel.
>>**how exactly:**
>>![](https://github.com/FZYsheep/MarkdownPicture/blob/1b2094241508e362bb87d3ca7e212fcbc115e489/control_transfer.png)
>>
>>We read the start address out of the ELF header and convert it from a 32-bit linear address into a 16:16 segment:offset(0x18) address for real mode, then jump to the converted address.The 80x86 doesn't have an instruction to jump to an absolute segment:offset kept in registers, so in fact we store the address in a temporary memory location(start), then use “ljmp” instruction to achieve control transfer.

#### QUESTIONS: KERNEL

>B7: At the entry of pintos_init(), what is the value of expression `init_page_dir[pd_no(ptov(0))]` in hexadecimal format?

>>

>B8: When `palloc_get_page()` is called for the first time,

>> B8.1 what does the call stack look like?
>>
>> 

>> B8.2 what is the return value in hexadecimal format?
>>
>> 

>> B8.3 what is the value of expression `init_page_dir[pd_no(ptov(0))]` in hexadecimal format?
>>
>> 



>B9: When palloc_get_page() is called for the third time,

>> B9.1 what does the call stack look like?
>>
>> 

>> B9.2 what is the return value in hexadecimal format?
>>
>> 

>> B9.3 what is the value of expression `init_page_dir[pd_no(ptov(0))]` in hexadecimal format?

>>c
>>x
>>



## Kernel Monitor

>C1: Put the screenshot of your kernel monitor running example here. (It should show how your kernel shell respond to `whoami`, `exit`, and `other input`.)

#### 

>C2: Explain how you read and write to the console for the kernel monitor.
