# Project 0: Getting Real

## Preliminaries

>Fill in your name and email address.
>>name:冯之乐 email address:2100012941@stu.pku.edu.cn
 

>If you have any preliminary comments on your submission, notes for the TAs, please give them here.



>Please cite any offline or online sources you consulted while preparing your submission, other than the Pintos documentation, course text, lecture notes, and course staff.



## Booting Pintos

>A1: Put the screenshot of Pintos running example here.
>>![qemu_boot](https://github.com/FZYsheep/MarkdownPicture/blob/8496823265644de9c392485a8c95069922613f1a/qemu_boot.png)
>>![bochs_boot](https://github.com/FZYsheep/MarkdownPicture/blob/8496823265644de9c392485a8c95069922613f1a/bochs_boot.png)


## Debugging

#### QUESTIONS: BIOS 

>B1: What is the first instruction that gets executed?

>> ljmp   $0x3630,$0xf000e05b

>B2: At which physical address is this instruction located?

>> 0xffff0


#### QUESTIONS: BOOTLOADER

>B3: How does the bootloader read disk sectors? In particular, what BIOS interrupt is used?

>> we should have a look at **read_sector**:
>> 
>> It first pushes some parameters essential for looking for the disk sector we are ready to read(CHS addressing),then uses BIOS interrupt 0x13.
>> 
>> This BIOS interrupt triggers a control transfer from user’s face program to an kernel’s face exception handler.
>> 
>> From [the picture](https://en.wikipedia.org/wiki/BIOS_interrupt_call#:~:text=Extended%20Read%20Sectors) on Wikipedia,we could know that this kind of BIOS interrupt can provide sector-based hard disk and floppy disk read and write services.
>> 
>> And from the line in loader.S,
>> 
>> mov $0x42,%ah
>> 
>> we can know exactly the functionality of the BIOS interrupt here is reading sectors from drive. 

>B4: How does the bootloader decides whether it successfully finds the Pintos kernel?

>>The loader's first job is to find the kernel by reading the partition table on each hard disk, looking for a bootable partition of the type used for a Pintos kernel.For example, IA32 bootloaders generally have to fit within 512 bytes in memory for a partition or floppy disk bootloader (i.e., only the first disk sector, and the last 2 bytes are fixed signatures for recognizing it is a bootloader).

>B5: What happens when the bootloader could not find the Pintos kernel?



>B6: At what point and how exactly does the bootloader transfer control to the Pintos kernel?



#### QUESTIONS: KERNEL

>B7: At the entry of pintos_init(), what is the value of expression `init_page_dir[pd_no(ptov(0))]` in hexadecimal format?

>>

>B8: When `palloc_get_page()` is called for the first time,

>> B8.1 what does the call stack look like?
>>
>> 

>> B8.2 what is the return value in hexadecimal format?
>>
>> 

>> B8.3 what is the value of expression `init_page_dir[pd_no(ptov(0))]` in hexadecimal format?
>>
>> 



>B9: When palloc_get_page() is called for the third time,

>> B9.1 what does the call stack look like?
>>
>> 

>> B9.2 what is the return value in hexadecimal format?
>>
>> 

>> B9.3 what is the value of expression `init_page_dir[pd_no(ptov(0))]` in hexadecimal format?
>>
>> 



## Kernel Monitor

>C1: Put the screenshot of your kernel monitor running example here. (It should show how your kernel shell respond to `whoami`, `exit`, and `other input`.)

#### 

>C2: Explain how you read and write to the console for the kernel monitor.
